import os
import re
import sys
from typing import Dict, List, Tuple, Any, Optional

# Regex definitions
MACRO_RE = re.compile(r'^#define\s+([a-zA-Z0-9_]+)\s+(.+)$', re.MULTILINE)
COMMENT_BLOCK_RE = re.compile(r'/\*.*?\*/', re.DOTALL)
COMMENT_LINE_RE = re.compile(r'//.*$', re.MULTILINE)
STRUCT_UNION_RE = re.compile(
    r'typedef\s+(struct|union)[^{]*\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}\s*(?:__attribute__\(\(packed\)\)\s*)?([a-zA-Z0-9_]+);',
    re.MULTILINE | re.DOTALL
)
FIELD_RE = re.compile(
    r'^\s*(?:const\s+)?([a-zA-Z0-9_]+)\s+([a-zA-Z0-9_]+)((?:\[[^\]]+\])*)(?:\s*:\s*\d+)?\s*;',
    re.MULTILINE
)
NESTED_UNION_RE = re.compile(
    r'union\s*(?:__attribute__\(\(packed\)\))?\s*\{((?:[^{}]|\{[^{}]*\})*)\};',
    re.MULTILINE | re.DOTALL
)

def clean_c_code(content: str) -> str:
    content = COMMENT_BLOCK_RE.sub('', content)
    content = COMMENT_LINE_RE.sub('', content)
    return content

def parse_macros(content: str) -> Dict[str, str]:
    macros = {}
    for match in MACRO_RE.finditer(content):
        # Keep numeric constants, simple hex, or simple expressions like (60)
        val = match.group(2).strip()
        # Remove parentheses for the check, or just loosely accept if it contains digits
        clean_val = re.sub(r'[\(\)\s]', '', val)
        if re.match(r'^[0-9A-Fa-fx\+\-\*\/]+$', clean_val) or 'x' in clean_val:
            macros[match.group(1)] = val
    
    # Inject default macros for arrays that are normally defined via compiler flags
    defaults = {
        "NUM_KEYS": "64",
        "NUM_LAYERS": "4",
        "NUM_PROFILES": "4",
        "NUM_MACROS": "16",
        "NUM_ADVANCED_KEYS": "32"
    }
    for k, v in defaults.items():
        if k not in macros:
            macros[k] = v
            
    return macros

def parse_structs(content: str) -> Dict[str, dict]:
    structs = {}
    for match in STRUCT_UNION_RE.finditer(content):
        is_union = match.group(1) == 'union'
        body = match.group(2)
        name = match.group(3)
        
        fields = []
        anonymous_unions = []
        for u_match in NESTED_UNION_RE.finditer(body):
            union_body = u_match.group(1)
            body = body.replace(u_match.group(0), '')
            anonymous_unions.append(union_body)
            
        for field_match in FIELD_RE.finditer(body):
            f_type = field_match.group(1)
            f_name = field_match.group(2)
            f_arrays_str = field_match.group(3)
            
            f_arrays = []
            if f_arrays_str:
                for dim_match in re.finditer(r'\[([^\]]+)\]', f_arrays_str):
                    f_arrays.append(dim_match.group(1).strip())
                    
            fields.append({
                'type': f_type,
                'name': f_name,
                'arrays': f_arrays
            })
            
        union_fields = []
        for union_body in anonymous_unions:
            # Only go one level deep for simplicity
            for field_match in FIELD_RE.finditer(union_body):
                f_type = field_match.group(1)
                f_name = field_match.group(2)
                f_arrays_str = field_match.group(3)
                
                f_arrays = []
                if f_arrays_str:
                    for dim_match in re.finditer(r'\[([^\]]+)\]', f_arrays_str):
                        f_arrays.append(dim_match.group(1).strip())
                union_fields.append({
                    'type': f_type,
                    'name': f_name,
                    'arrays': f_arrays
                })
        
        if fields or union_fields:
            structs[name] = {
                'is_union': is_union,
                'fields': fields,
                'anonymous_unions': [union_fields] if union_fields else []
            }
            
    return structs

def camel_case(s: str) -> str:
    parts = s.split('_')
    return parts[0] + ''.join(x.capitalize() for x in parts[1:])

def pascal_case(s: str) -> str:
    return s.replace("_t", "").title().replace("_", "")

def generate_ts(structs: Dict[str, dict], macros: Dict[str, str]) -> str:
    out = [
        "// AUTO-GENERATED FILE. DO NOT EDIT.", 
        "// This file is generated by gen_ts_types.py",
        "import { DataViewReader } from \"$lib/data-view-reader\"", 
        ""
    ]
    
    for k, v in macros.items():
        if k.startswith("NUM_") or k.startswith("MAX_") or k.startswith("EECONFIG_"):
            out.append(f"export const {k} = {v}")
    
    out.append("")
    
    ts_types = {
        "uint8_t": "number",
        "uint16_t": "number",
        "uint32_t": "number",
        "int8_t": "number",
        "int16_t": "number",
        "int32_t": "number",
        "bool": "boolean",
    }
    
    view_methods = {
        "uint8_t": "uint8()",
        "uint16_t": "uint16()",
        "uint32_t": "uint32()",
    }
    
    for name, info in structs.items():
        ts_name = pascal_case(name)
        
        # Determine interface or union
        out.append(f"export interface {ts_name} {{")
        for field in info['fields']:
            ts_f_type = ts_types.get(field['type'], pascal_case(field['type']))
            ts_f_name = camel_case(field['name'])
            arr_decl = "".join(["[]" for _ in field['arrays']])
            out.append(f"  {ts_f_name}: {ts_f_type}{arr_decl}")
            
        for union_group in info['anonymous_unions']:
            out.append("  // Union fields (made optional since only one is active at a time)")
            for field in union_group:
                ts_f_type = ts_types.get(field['type'], pascal_case(field['type']))
                ts_f_name = camel_case(field['name'])
                arr_decl = "".join(["[]" for _ in field['arrays']])
                out.append(f"  {ts_f_name}?: {ts_f_type}{arr_decl}")

        out.append("}\n")

    out.append("export function parseBool(reader: DataViewReader): boolean {")
    out.append("  return reader.uint8() !== 0")
    out.append("}\n")
    
    for name, info in structs.items():
        ts_name = pascal_case(name)
        
        out.append(f"export function parse{ts_name}(reader: DataViewReader): {ts_name} {{")
        if info['is_union'] or name == "gamepad_options_t":
            out.append("  // For exact union parsing, we either backtrack or manually read flags.")
            out.append("  // Gamepad options overlay uint8_t raw flags. We will just read a byte since we only have options mapping for Gamepad options.")
            if name == "gamepad_options_t":
                out.append("  const options = reader.uint8()")
                out.append("  return { options } as any")
            elif name == "eeconfig_options_t":
                out.append("  const raw = reader.uint16()")
                out.append("  return { raw } as any")
            else:
                out.append("  return {} as any // Generic Union fallback")
            out.append("}\n")
            continue
            
        if name == "advanced_key_t":
            # Manual override parser to use the 'type' field
            out.append("""  const layer = reader.uint8()
  const key = reader.uint8()
  const type = reader.uint8()
  // Data for advanced key is 10 bytes max (tap_hold_t = 10 bytes with double_tap_keycode).
  // Note: if reading union, we must skip remaining bytes so we always consume ADVANCED_KEY_SIZE (13 bytes)
  const result: any = { layer, key, type }

  switch (type) {
    case 1: // AK_TYPE_NULL_BIND
      result.nullBind = parseNullBind(reader)
      reader.offset += 7 // skip remaining bytes (13 - 3 header - 3 struct = 7)
      break
    case 2: // AK_TYPE_DYNAMIC_KEYSTROKE
      result.dynamicKeystroke = parseDynamicKeystroke(reader)
      reader.offset += 1 // 13 - 3 - 9 = 1 skip
      break
    case 3: // AK_TYPE_TAP_HOLD
      result.tapHold = parseTapHold(reader)
      // 13 - 3 - 10 = 0 skips
      break
    case 4: // AK_TYPE_TOGGLE
      result.toggle = parseToggle(reader)
      reader.offset += 7 // 13 - 3 - 3 = 7 skips
      break
    case 5: // AK_TYPE_COMBO
      result.combo = parseCombo(reader)
      reader.offset += 3 // 13 - 3 - 7 = 3 skips
      break
    case 6: // AK_TYPE_MACRO
      result.macroKey = parseMacroKey(reader)
      reader.offset += 9 // 13 - 3 - 1 = 9 skips
      break
    default:
      reader.offset += 10 // exhaust empty action bytes
      break
  }
  return result as AdvancedKey
}""")
            continue
            
        out.append("  const result = {} as any")
        for field in info['fields']:
            ts_f_name = camel_case(field['name'])
            f_type = field['type']
            method = view_methods.get(f_type)
            inner_ts_name = pascal_case(f_type)
            
            if not field['arrays']:
                if method:
                    if f_type == "bool":
                        out.append(f"  result.{ts_f_name} = reader.uint8() !== 0")
                    else:
                        out.append(f"  result.{ts_f_name} = reader.{method}")
                else:
                    out.append(f"  result.{ts_f_name} = parse{inner_ts_name}(reader)")
            else:
                def gen_array(arrays: List[str], current_dim: int) -> str:
                    dim_str = arrays[current_dim]
                    dim = macros.get(dim_str, dim_str)
                    
                    inner: str
                    if current_dim == len(arrays) - 1:
                        if method:
                            inner = f"() => reader.{method}"
                        else:
                            inner = f"() => parse{inner_ts_name}(reader)"
                    else:
                        inner_str = gen_array(arrays, current_dim + 1)
                        inner = f"() => {inner_str}"
                        
                    return f"Array.from({{ length: {dim} }}, {inner})"

                out.append(f"  result.{ts_f_name} = {gen_array(field['arrays'], 0)}")
                
        out.append("  return result")
        out.append("}\n")
        
    return "\n".join(out)

def main():
    if len(sys.argv) < 3:
        print("Usage: python gen_ts_types.py <input1.h ...> <output.ts>")
        sys.exit(1)
        
    input_files = sys.argv[1:-1]
    output_file = sys.argv[-1]
    
    content = ""
    for file in input_files:
        with open(file, 'r') as f:
            content += f.read() + "\n"
            
    content = clean_c_code(content)
    macros = parse_macros(content)
    structs = parse_structs(content)
    
    ts_code = generate_ts(structs, macros)
    
    with open(output_file, 'w') as f:
        f.write(ts_code)
        
    print(f"Generated {output_file}")
    
if __name__ == "__main__":
    main()
